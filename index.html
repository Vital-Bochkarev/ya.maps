<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Карта из GeoJSON (автодетект порядка координат)</title>
  <style>
    html,body { height:100%; margin:0; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #wrap { display:grid; grid-template-columns:360px 1fr; height:100%; }
    #list { border-right:1px solid #e5e7eb; overflow:auto; }
    #map  { width:100%; height:100%; }
    .list-header { position:sticky; top:0; background:#fff; z-index:1; padding:.5rem .75rem; border-bottom:1px solid #e5e7eb; font-weight:600; }
    table { width:100%; border-collapse:collapse; }
    thead th { text-align:left; font-weight:600; color:#6b7280; padding:.5rem .75rem; position:sticky; top:36px; background:#fff; border-bottom:1px solid #e5e7eb; }
    tbody td { padding:.5rem .75rem; border-bottom:1px solid #f3f4f6; vertical-align:top; }
    tbody tr { cursor:pointer; }
    tbody tr:hover { background:#f9fafb; }
    #diag { position:fixed; right:8px; bottom:8px; background:#111; color:#fff; padding:4px 8px; border-radius:6px; font:12px/1.3 monospace; opacity:.9; z-index:9999; }
  </style>

  <!-- ВСТАВЬТЕ СВОЙ API-КЛЮЧ -->
  <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU&coordorder=longlat&apikey=ВАШ_API_KEY"></script>
</head>
<body>
  <div id="wrap">
    <aside id="list">
      <div class="list-header">Список объектов</div>
      <table>
        <thead>
        <tr><th style="width:55%">Городской округ</th><th>Название</th></tr>
        </thead>
        <tbody id="featList"><tr><td colspan="2">Загрузка…</td></tr></tbody>
      </table>
    </aside>
    <div id="map"></div>
  </div>
  <div id="diag">init…</div>

<script>
const SRC_GEOJSON = "https://gist.githubusercontent.com/Vital-Bochkarev/b96a1680d32b83086de812eddabb31cf/raw/69ce2f478a9f8990b482fdd6348de02387593212/map.geojson";

const esc  = s => String(s ?? '').replace(/[&<>\"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch]));
const diag = t => { const el = document.getElementById('diag'); if (el) el.textContent = t; };

// максимально заметные стили поверх всего
const POLY_STYLE = {
  fillColor:   '#00ff66',
  fillOpacity: 0.8,
  strokeColor: '#003300',
  strokeOpacity: 1,
  strokeWidth: 5,
  zIndex: 100000,
  zIndexHover: 100001,
  hasHint: false,
  hasBalloon: false
};

// ------------ ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ -----------------

function toFC(obj){
  if (obj?.type === 'FeatureCollection') return obj;
  if (obj?.type === 'Feature') return { type:'FeatureCollection', features:[obj] };
  return { type:'FeatureCollection', features:[{ type:'Feature', geometry:obj, properties:{} }] };
}

const isFiniteNum = v => Number.isFinite(Number(v));

// Выборка нескольких точек из геометрии
function* iteratePoints(geom){
  const t = geom.type, c = geom.coordinates;
  if (t === 'Point') {
    yield c;
  } else if (t === 'MultiPoint' || t === 'LineString') {
    for (const p of c) yield p;
  } else if (t === 'MultiLineString' || t === 'Polygon') {
    for (const ring of c) for (const p of ring) yield p;
  } else if (t === 'MultiPolygon') {
    for (const poly of c) for (const ring of poly) for (const p of ring) yield p;
  } else if (t === 'GeometryCollection') {
    for (const g of (geom.geometries||[])) yield* iteratePoints(g);
  }
}

// true  → вероятно [lat, lon] → нужно свапнуть
// false → вероятно [lon, lat] → оставляем как есть
function needSwapOrder(geom){
  let total = 0, latLonLike = 0;
  for (const p of iteratePoints(geom)) {
    if (!Array.isArray(p) || p.length < 2) continue;
    const a = Number(p[0]), b = Number(p[1]);
    if (!isFiniteNum(a) || !isFiniteNum(b)) continue;
    total++;
    const firstIsLat  = a >= -90 && a <= 90;
    const secondIsLon = b >= -180 && b <= 180 && Math.abs(b) > 90; // у долгот чаще модуль > 90
    if (firstIsLat && secondIsLon) latLonLike++;
    if (total >= 50) break; // достаточно выборки
  }
  if (!total) return false;
  return (latLonLike / total) > 0.6; // если большинство «похоже» на [lat,lon]
}

// нормализация координат: числа + при необходимости меняем порядок [lat,lon] → [lon,lat]
function normalizeGeometry(geom){
  const swap = needSwapOrder(geom);
  const normPair = p => {
    const a = Number(p[0]), b = Number(p[1]);
    return swap ? [b, a] : [a, b];
  };
  const t = geom.type, c = geom.coordinates;
  if (t === 'Point') geom.coordinates = normPair(c);
  else if (t === 'MultiPoint' || t === 'LineString') geom.coordinates = (c||[]).map(normPair);
  else if (t === 'MultiLineString' || t === 'Polygon') geom.coordinates = (c||[]).map(r => (r||[]).map(normPair));
  else if (t === 'MultiPolygon') geom.coordinates = (c||[]).map(p => (p||[]).map(r => (r||[]).map(normPair)));
  else if (t === 'GeometryCollection') (geom.geometries||[]).forEach(normalizeGeometry);
  return geom;
}

// фиксим кольца: фильтр мусора, замыкаем, минимальная длина
function fixRing(r){
  const out = [];
  for (const p of r) {
    if (!Array.isArray(p) || p.length < 2) continue;
    const lon = Number(p[0]), lat = Number(p[1]);
    if (!Number.isFinite(lon) || !Number.isFinite(lat)) continue;
    out.push([lon, lat]);
  }
  if (out.length < 4) return null;
  const a = out[0], b = out[out.length-1];
  if (a[0] !== b[0] || a[1] !== b[1]) out.push([a[0], a[1]]);
  return out;
}
function fixPolygon(poly){
  const rings = [];
  for (const r of poly) {
    const rr = fixRing(r);
    if (rr) rings.push(rr);
  }
  return rings.length ? rings : null;
}
function fixMultiPolygon(mpoly){
  const polys = [];
  for (const p of mpoly) {
    const pp = fixPolygon(p);
    if (pp) polys.push(pp);
  }
  return polys.length ? polys : null;
}

// создаём геообъект: для Polygon оборачиваем в MultiPolygon, чтобы везде была единая логика
function makeMultiPolygonObject(feature){
  const g = feature.geometry;
  let coords = null;

  if (g.type === 'MultiPolygon') {
    coords = fixMultiPolygon(g.coordinates);
  } else if (g.type === 'Polygon') {
    const fixed = fixPolygon(g.coordinates);
    coords = fixed ? [fixed] : null;
  } else if (g.type === 'GeometryCollection') {
    const polys = [];
    (g.geometries||[]).forEach(gg => {
      if (gg.type === 'Polygon') {
        const fixed = fixPolygon(gg.coordinates);
        if (fixed) polys.push(fixed);
      } else if (gg.type === 'MultiPolygon') {
        const fixed = fixMultiPolygon(gg.coordinates);
        if (fixed) polys.push(...fixed);
      }
    });
    coords = polys.length ? polys : null;
  } else {
    return null; // не-полигонные геометрии пропускаем
  }

  if (!coords || !coords.length) return null;

  return new ymaps.GeoObject(
    { geometry: { type:'MultiPolygon', coordinates: coords }, properties: feature.properties || {} },
    POLY_STYLE
  );
}

// список слева
function buildList(fc, focus){
  const tbody = document.getElementById('featList');
  tbody.innerHTML = '';
  if (!fc.features?.length){
    tbody.innerHTML = '<tr><td colspan="2">Нет данных</td></tr>';
    return;
  }
  fc.features.forEach((f, i) => {
    const p = f.properties || {};
    const okrug = (p.Name ?? p.NAME ?? p.name ?? p.title ?? '—');
    const name  = (p.description ?? '—');
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${esc(okrug)}</td><td>${esc(name)}</td>`;
    tr.onclick = () => focus(i);
    tbody.appendChild(tr);
  });
}

// ------------ ОСНОВНОЙ КОД -----------------

let map, objects = [];

function overallBounds(){
  try {
    const col = new ymaps.GeoObjectCollection();
    objects.forEach(o => col.add(o));
    return col.getBounds();
  } catch { return null; }
}

async function loadAndRender(){
  const res = await fetch(SRC_GEOJSON, { cache:'no-store' });
  if (!res.ok) throw new Error('HTTP ' + res.status);
  const raw = await res.json();
  const fc  = toFC(raw);

  // нормализация/детект порядка координат per-feature
  let added = 0, skipped = 0;
  fc.features.forEach(f => {
    if (!f.geometry) { skipped++; return; }
    normalizeGeometry(f.geometry);
    const obj = makeMultiPolygonObject(f);
    if (obj) {
      map.geoObjects.add(obj);
      objects.push(obj);
      added++;
    } else {
      skipped++;
    }
  });

  buildList(fc, (idx) => {
    const o = objects[idx];
    if (!o) return;
    const b = o.geometry.getBounds?.() || overallBounds();
    if (b) map.setBounds(b, { checkZoomRange:true });
  });

  const b = overallBounds();
  if (b) map.setBounds(b, { checkZoomRange:true });

  diag(`OK: добавлено мультиполигонов: ${added}` + (skipped?`, пропущено: ${skipped}`:''));
}

ymaps.ready(() => {
  map = new ymaps.Map('map', {
    center:[37.618423,55.751244], // долгота, широта
    zoom:7,
    controls:['zoomControl','typeSelector','fullscreenControl']
  });
  // Контрастная подложка, чтобы заливка точно была видна
  // map.setType('yandex#hybrid'); // можно включить при желании
  loadAndRender().catch(e => { console.error(e); diag('Ошибка: '+e.message); });
});
</script>
</body>
</html>
